"""This script is useful for spatial sampling of image chips. Please note that image chips are first generated by ArcGIS pro deep learning tool that exports eimage to classified tiles
See the documentation here https://pro.arcgis.com/en/pro-app/latest/tool-reference/image-analyst/export-training-data-for-deep-learning.htm"""

##########################

import geopandas as gpd
from shapely.geometry import Polygon, Point
import numpy as np
import rasterio
import random
from matplotlib.pyplot import figure
import matplotlib.pyplot as plt
import matplotlib.patches as mpatches
from tqdm import tqdm
import os
import math


def spatialSampling(files, outpath, chips_per_block=4, train_ratio=0.7, valid_ratio=0.15, test_ratio=0.15, plot=True):
    XMIN, YMIN, XMAX, YMAX = [], [], [], []
    w, h, ww, hh = 0, 0, 0, 0

    all_points = []

    print("Generating chip extents and fishnet ...")
    for i, file in tqdm(enumerate(files)):
        rst = rasterio.open(file).bounds
        xmin, ymin, xmax, ymax = list(rst)
        x = xmin + (xmax - xmin) / 2
        y = ymin + (ymax - ymin) / 2
        pp = Point(x, y)
        all_points.append(pp)
        XMIN.append(xmin)
        YMIN.append(ymin)
        XMAX.append(xmax)
        YMAX.append(ymax)

        if i == 0:
            w = rst.right - rst.left
            h = rst.top - rst.bottom
            width = w * chips_per_block
            length = h * chips_per_block

    # bounds for entire study site
    xmin_, ymin_, xmax_, ymax_ = min(XMIN), min(YMIN), max(XMAX), max(YMAX)
    cols = list(np.arange(xmin_, xmax_ + width, width))
    rows = list(np.arange(ymin_, ymax_ + length, length))

    polygons = []  # fishnet blocks
    for x in cols[:-1]:
        for y in rows[:-1]:
            polygons.append(Polygon([(x, y), (x + width, y), (x + width, y + length), (x, y + length)]))

    # remove emty polygons that may not contain image chips
    valid_poly = [poly for poly in polygons if True in [poly.contains(pt) for pt in all_points]]

    N = len(valid_poly)
    tr = int(N * train_ratio)
    ts = int(N * valid_ratio)
    vs = int(N * test_ratio)

    inds = list(range(N))
    space = int(N / (ts + vs))  # test and validation together
    tr_lvs = list(range(0, 78, space))  # indices for testing and validation

    t_inds = list(set(inds).symmetric_difference(set(tr_lvs)))
    v_ind = random.sample(tr_lvs, int(len(tr_lvs) / 2))
    ts_ind = list(set(tr_lvs).symmetric_difference(v_ind))

    tpoly = [valid_poly[ti] for ti in t_inds]
    tspoly = [valid_poly[ts] for ts in ts_ind]
    vspoly = [valid_poly[vi] for vi in v_ind]

    # summarize
    print('Number of training blocks: ', len(tpoly))
    print('Number of test blocks: ', len(tspoly))
    print('Number of validation blocks: ', len(vspoly))

    # iterate on points and partition

    if os.path.exists(outpath):
        print(f'Folder {outpath} exists. Outputs with the same name will be overwritten')
    else:
        os.makedirs(outpath, exist_ok=True)
        print(f'Outputs will be written to: {outpath}')

    txt_train = open(f'{outpath}/train.txt', 'w+')
    txt_valid = open(f'{outpath}/valid.txt', 'w+')
    txt_test = open(f'{outpath}/test.txt', 'w+')

    for j, pt in tqdm(enumerate(all_points)):
        if True in [poly.contains(pt) for poly in tpoly]:  # training samples
            name = os.path.split(files[j])[1]
            txt_train.write(name + "\n")
        elif True in [poly.contains(pt) for poly in tspoly]:  # testing samples
            name = os.path.split(files[j])[1]
            txt_test.write(name + "\n")
        else:
            name = os.path.split(files[j])[1]
            txt_valid.write(name + "\n")

    txt_train.close()
    txt_valid.close()
    txt_test.close()

    if plot:
        fig, ax = plt.subplots(figsize=(7, 7))
        train_patch = mpatches.Patch(color='green', label='Trian')
        test_patch = mpatches.Patch(color='blue', label='test')
        valid_patch = mpatches.Patch(color='red', label='valid')

        for i in range(len(tpoly)):
            ax.plot(*tpoly[i].exterior.xy, label='train', c='g')
        for i in range(len(tspoly)):
            ax.plot(*tspoly[i].exterior.xy, label='test', c='b')
        for i in range(len(vspoly)):
            ax.plot(*vspoly[i].exterior.xy, label='valid', c='r')
        for pt in all_points:
            if True in [poly.contains(pt) for poly in tpoly]:
                ax.scatter(pt.x, pt.y, s=1, c='g')
            elif True in [poly.contains(pt) for poly in tspoly]:
                ax.scatter(pt.x, pt.y, s=1, c='b')
            else:
                ax.scatter(pt.x, pt.y, s=1, c='r')
        ax.legend(handles=[train_patch, valid_patch, test_patch])

    plt.xlabel('Longitude')
    plt.ylabel('Latitude')
    plt.yticks(rotation='vertical')
    plt.gca().ticklabel_format(axis='y', style='plain', useOffset=True)

    plt.savefig(f'{outpath}/sampling.png', dpi=350, bbox_inches='tight')
    plt.show()


if __name__ == "__main__":
    data_dir = input("Please past data directory where images are saved:  ")
    out_dir = input("Plase past output directory to save the partitioning reports:  ")
    chips_per_block = int(input("Plase indicate number of chips per block:  "))
    print("=============================================================")
    print("The sum of train, valid and test ratio should nt be grater than 1")
    print("=============================================================")
    train_ratio = float(input("Please indicate training ratio [0,1]: "))
    valid_ratio = float(input("Please indicate validation ratio [0,1]: "))
    test_ratio = float(input("Plaese indicate test ratio [0,1]: "))

    assert int(chips_per_block) >= 4, 'The minimum number of chips per block is 4 given fishnets are squre tesselations'
    assert math.sqrt(chips_per_block) - int(
        math.sqrt(chips_per_block)) == 0, 'The specified number is chips is not fitting into square tesselations'

    files = [f'{data_dir}/{file}' for file in os.listdir(data_dir)]
    spatialSampling(files=files,
                    outpath=out_dir,
                    train_ratio=train_ratio,
                    valid_ratio=valid_ratio,
                    test_ratio=test_ratio,
                    plot=True)

#######USAGE ####################
# python spatial_sampling.py
# then respond for the prompts
###################################
